# Generated from Enquestes.g by ANTLR 4.7.1
# encoding: utf-8
import sys
from io import StringIO
from typing.io import TextIO

from antlr4 import *


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\31")
        buf.write("v\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b")
        buf.write("\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\3\2\3\2")
        buf.write("\3\2\3\2\3\3\3\3\3\3\3\3\3\3\7\3$\n\3\f\3\16\3\'\13\3")
        buf.write("\3\4\3\4\3\4\3\4\7\4-\n\4\f\4\16\4\60\13\4\3\4\3\4\3\5")
        buf.write("\3\5\3\5\3\5\7\58\n\5\f\5\16\5;\13\5\3\6\3\6\3\6\7\6@")
        buf.write("\n\6\f\6\16\6C\13\6\3\6\3\6\3\7\3\7\3\7\3\7\7\7K\n\7\f")
        buf.write("\7\16\7N\13\7\3\b\3\b\3\b\3\b\3\t\3\t\3\t\3\t\3\t\3\n")
        buf.write("\3\n\3\n\3\n\3\n\3\13\3\13\3\13\3\13\7\13b\n\13\f\13\16")
        buf.write("\13e\13\13\3\f\3\f\3\f\3\f\3\f\3\f\3\r\3\r\3\r\3\r\7\r")
        buf.write("q\n\r\f\r\16\rt\13\r\3\r\2\2\16\2\4\6\b\n\f\16\20\22\24")
        buf.write("\26\30\2\2\2u\2\32\3\2\2\2\4%\3\2\2\2\6(\3\2\2\2\b\63")
        buf.write("\3\2\2\2\n<\3\2\2\2\fF\3\2\2\2\16O\3\2\2\2\20S\3\2\2\2")
        buf.write("\22X\3\2\2\2\24c\3\2\2\2\26f\3\2\2\2\30l\3\2\2\2\32\33")
        buf.write("\5\4\3\2\33\34\7\25\2\2\34\35\7\2\2\3\35\3\3\2\2\2\36")
        buf.write("$\5\6\4\2\37$\5\b\5\2 $\5\f\7\2!$\5\20\t\2\"$\5\30\r\2")
        buf.write("#\36\3\2\2\2#\37\3\2\2\2# \3\2\2\2#!\3\2\2\2#\"\3\2\2")
        buf.write("\2$\'\3\2\2\2%#\3\2\2\2%&\3\2\2\2&\5\3\2\2\2\'%\3\2\2")
        buf.write("\2()\7\7\2\2)*\7\27\2\2*.\7\17\2\2+-\7\26\2\2,+\3\2\2")
        buf.write("\2-\60\3\2\2\2.,\3\2\2\2./\3\2\2\2/\61\3\2\2\2\60.\3\2")
        buf.write("\2\2\61\62\7\30\2\2\62\7\3\2\2\2\63\64\7\6\2\2\64\65\7")
        buf.write("\27\2\2\659\7\20\2\2\668\5\n\6\2\67\66\3\2\2\28;\3\2\2")
        buf.write("\29\67\3\2\2\29:\3\2\2\2:\t\3\2\2\2;9\3\2\2\2<=\7\24\2")
        buf.write("\2=A\7\27\2\2>@\7\26\2\2?>\3\2\2\2@C\3\2\2\2A?\3\2\2\2")
        buf.write("AB\3\2\2\2BD\3\2\2\2CA\3\2\2\2DE\7\22\2\2E\13\3\2\2\2")
        buf.write("FG\7\5\2\2GH\7\27\2\2HL\7\16\2\2IK\5\16\b\2JI\3\2\2\2")
        buf.write("KN\3\2\2\2LJ\3\2\2\2LM\3\2\2\2M\r\3\2\2\2NL\3\2\2\2OP")
        buf.write("\7\7\2\2PQ\7\23\2\2QR\7\6\2\2R\17\3\2\2\2ST\7\3\2\2TU")
        buf.write("\7\27\2\2UV\7\21\2\2VW\5\22\n\2W\21\3\2\2\2XY\7\5\2\2")
        buf.write("YZ\7\t\2\2Z[\5\24\13\2[\\\7\n\2\2\\\23\3\2\2\2]^\5\26")
        buf.write("\f\2^_\7\b\2\2_b\3\2\2\2`b\5\26\f\2a]\3\2\2\2a`\3\2\2")
        buf.write("\2be\3\2\2\2ca\3\2\2\2cd\3\2\2\2d\25\3\2\2\2ec\3\2\2\2")
        buf.write("fg\7\13\2\2gh\7\24\2\2hi\7\b\2\2ij\7\5\2\2jk\7\f\2\2k")
        buf.write("\27\3\2\2\2lm\7\4\2\2mn\7\27\2\2nr\7\r\2\2oq\7\5\2\2p")
        buf.write("o\3\2\2\2qt\3\2\2\2rp\3\2\2\2rs\3\2\2\2s\31\3\2\2\2tr")
        buf.write("\3\2\2\2\13#%.9ALacr")
        return buf.getvalue()


class EnquestesParser(Parser):
    grammarFileName = "Enquestes.g"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]

    sharedContextCache = PredictionContextCache()

    literalNames = ["<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                    "<INVALID>", "<INVALID>", "','", "'['", "']'", "'('",
                    "')'", "'ENQUESTA'", "'ITEM'", "'PREGUNTA'", "'RESPOSTA'",
                    "'ALTERNATIVA'", "';'", "'->'", "<INVALID>", "'END'",
                    "<INVALID>", "':'", "'?'"]

    symbolicNames = ["<INVALID>", "AID", "EID", "IID", "RID", "PID", "COMA",
                     "CE", "CD", "PE", "PR", "ENQUESTA", "ELEMENT", "PREGUNTA",
                     "RESPOSTA", "ALTERNATIVA", "PUNTCOMA", "FLETXA", "NUMERO",
                     "FINAL", "PARAULES", "PUNTS", "SIGNEPREGUNTA", "WS"]

    RULE_root = 0
    RULE_blocs = 1
    RULE_pregunta = 2
    RULE_resposta = 3
    RULE_opcio = 4
    RULE_element = 5
    RULE_relacio = 6
    RULE_alternativa = 7
    RULE_implications = 8
    RULE_blocrespostaelement = 9
    RULE_respostaelement = 10
    RULE_enquesta = 11

    ruleNames = ["root", "blocs", "pregunta", "resposta", "opcio", "element",
                 "relacio", "alternativa", "implications", "blocrespostaelement",
                 "respostaelement", "enquesta"]

    EOF = Token.EOF
    AID = 1
    EID = 2
    IID = 3
    RID = 4
    PID = 5
    COMA = 6
    CE = 7
    CD = 8
    PE = 9
    PR = 10
    ENQUESTA = 11
    ELEMENT = 12
    PREGUNTA = 13
    RESPOSTA = 14
    ALTERNATIVA = 15
    PUNTCOMA = 16
    FLETXA = 17
    NUMERO = 18
    FINAL = 19
    PARAULES = 20
    PUNTS = 21
    SIGNEPREGUNTA = 22
    WS = 23

    def __init__(self, input: TokenStream, output: TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None

    class RootContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def blocs(self):
            return self.getTypedRuleContext(EnquestesParser.BlocsContext, 0)

        def FINAL(self):
            return self.getToken(EnquestesParser.FINAL, 0)

        def EOF(self):
            return self.getToken(EnquestesParser.EOF, 0)

        def getRuleIndex(self):
            return EnquestesParser.RULE_root

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRoot"):
                return visitor.visitRoot(self)
            else:
                return visitor.visitChildren(self)

    def root(self):

        localctx = EnquestesParser.RootContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_root)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 24
            self.blocs()
            self.state = 25
            self.match(EnquestesParser.FINAL)
            self.state = 26
            self.match(EnquestesParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BlocsContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pregunta(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(EnquestesParser.PreguntaContext)
            else:
                return self.getTypedRuleContext(EnquestesParser.PreguntaContext, i)

        def resposta(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(EnquestesParser.RespostaContext)
            else:
                return self.getTypedRuleContext(EnquestesParser.RespostaContext, i)

        def element(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(EnquestesParser.ElementContext)
            else:
                return self.getTypedRuleContext(EnquestesParser.ElementContext, i)

        def alternativa(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(EnquestesParser.AlternativaContext)
            else:
                return self.getTypedRuleContext(EnquestesParser.AlternativaContext, i)

        def enquesta(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(EnquestesParser.EnquestaContext)
            else:
                return self.getTypedRuleContext(EnquestesParser.EnquestaContext, i)

        def getRuleIndex(self):
            return EnquestesParser.RULE_blocs

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBlocs"):
                return visitor.visitBlocs(self)
            else:
                return visitor.visitChildren(self)

    def blocs(self):

        localctx = EnquestesParser.BlocsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_blocs)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 35
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << EnquestesParser.AID) | (1 << EnquestesParser.EID) | (1 << EnquestesParser.IID) | (
                    1 << EnquestesParser.RID) | (1 << EnquestesParser.PID))) != 0):
                self.state = 33
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [EnquestesParser.PID]:
                    self.state = 28
                    self.pregunta()
                    pass
                elif token in [EnquestesParser.RID]:
                    self.state = 29
                    self.resposta()
                    pass
                elif token in [EnquestesParser.IID]:
                    self.state = 30
                    self.element()
                    pass
                elif token in [EnquestesParser.AID]:
                    self.state = 31
                    self.alternativa()
                    pass
                elif token in [EnquestesParser.EID]:
                    self.state = 32
                    self.enquesta()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 37
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PreguntaContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PID(self):
            return self.getToken(EnquestesParser.PID, 0)

        def PUNTS(self):
            return self.getToken(EnquestesParser.PUNTS, 0)

        def PREGUNTA(self):
            return self.getToken(EnquestesParser.PREGUNTA, 0)

        def SIGNEPREGUNTA(self):
            return self.getToken(EnquestesParser.SIGNEPREGUNTA, 0)

        def PARAULES(self, i: int = None):
            if i is None:
                return self.getTokens(EnquestesParser.PARAULES)
            else:
                return self.getToken(EnquestesParser.PARAULES, i)

        def getRuleIndex(self):
            return EnquestesParser.RULE_pregunta

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPregunta"):
                return visitor.visitPregunta(self)
            else:
                return visitor.visitChildren(self)

    def pregunta(self):

        localctx = EnquestesParser.PreguntaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_pregunta)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 38
            self.match(EnquestesParser.PID)
            self.state = 39
            self.match(EnquestesParser.PUNTS)
            self.state = 40
            self.match(EnquestesParser.PREGUNTA)
            self.state = 44
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == EnquestesParser.PARAULES:
                self.state = 41
                self.match(EnquestesParser.PARAULES)
                self.state = 46
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 47
            self.match(EnquestesParser.SIGNEPREGUNTA)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RespostaContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RID(self):
            return self.getToken(EnquestesParser.RID, 0)

        def PUNTS(self):
            return self.getToken(EnquestesParser.PUNTS, 0)

        def RESPOSTA(self):
            return self.getToken(EnquestesParser.RESPOSTA, 0)

        def opcio(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(EnquestesParser.OpcioContext)
            else:
                return self.getTypedRuleContext(EnquestesParser.OpcioContext, i)

        def getRuleIndex(self):
            return EnquestesParser.RULE_resposta

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitResposta"):
                return visitor.visitResposta(self)
            else:
                return visitor.visitChildren(self)

    def resposta(self):

        localctx = EnquestesParser.RespostaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_resposta)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 49
            self.match(EnquestesParser.RID)
            self.state = 50
            self.match(EnquestesParser.PUNTS)
            self.state = 51
            self.match(EnquestesParser.RESPOSTA)
            self.state = 55
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == EnquestesParser.NUMERO:
                self.state = 52
                self.opcio()
                self.state = 57
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OpcioContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMERO(self):
            return self.getToken(EnquestesParser.NUMERO, 0)

        def PUNTS(self):
            return self.getToken(EnquestesParser.PUNTS, 0)

        def PUNTCOMA(self):
            return self.getToken(EnquestesParser.PUNTCOMA, 0)

        def PARAULES(self, i: int = None):
            if i is None:
                return self.getTokens(EnquestesParser.PARAULES)
            else:
                return self.getToken(EnquestesParser.PARAULES, i)

        def getRuleIndex(self):
            return EnquestesParser.RULE_opcio

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOpcio"):
                return visitor.visitOpcio(self)
            else:
                return visitor.visitChildren(self)

    def opcio(self):

        localctx = EnquestesParser.OpcioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_opcio)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 58
            self.match(EnquestesParser.NUMERO)
            self.state = 59
            self.match(EnquestesParser.PUNTS)
            self.state = 63
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == EnquestesParser.PARAULES:
                self.state = 60
                self.match(EnquestesParser.PARAULES)
                self.state = 65
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 66
            self.match(EnquestesParser.PUNTCOMA)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ElementContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IID(self):
            return self.getToken(EnquestesParser.IID, 0)

        def PUNTS(self):
            return self.getToken(EnquestesParser.PUNTS, 0)

        def ELEMENT(self):
            return self.getToken(EnquestesParser.ELEMENT, 0)

        def relacio(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(EnquestesParser.RelacioContext)
            else:
                return self.getTypedRuleContext(EnquestesParser.RelacioContext, i)

        def getRuleIndex(self):
            return EnquestesParser.RULE_element

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitElement"):
                return visitor.visitElement(self)
            else:
                return visitor.visitChildren(self)

    def element(self):

        localctx = EnquestesParser.ElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_element)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 68
            self.match(EnquestesParser.IID)
            self.state = 69
            self.match(EnquestesParser.PUNTS)
            self.state = 70
            self.match(EnquestesParser.ELEMENT)
            self.state = 74
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 5, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 71
                    self.relacio()
                self.state = 76
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 5, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RelacioContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PID(self):
            return self.getToken(EnquestesParser.PID, 0)

        def FLETXA(self):
            return self.getToken(EnquestesParser.FLETXA, 0)

        def RID(self):
            return self.getToken(EnquestesParser.RID, 0)

        def getRuleIndex(self):
            return EnquestesParser.RULE_relacio

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRelacio"):
                return visitor.visitRelacio(self)
            else:
                return visitor.visitChildren(self)

    def relacio(self):

        localctx = EnquestesParser.RelacioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_relacio)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 77
            self.match(EnquestesParser.PID)
            self.state = 78
            self.match(EnquestesParser.FLETXA)
            self.state = 79
            self.match(EnquestesParser.RID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AlternativaContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AID(self):
            return self.getToken(EnquestesParser.AID, 0)

        def PUNTS(self):
            return self.getToken(EnquestesParser.PUNTS, 0)

        def ALTERNATIVA(self):
            return self.getToken(EnquestesParser.ALTERNATIVA, 0)

        def implications(self):
            return self.getTypedRuleContext(EnquestesParser.ImplicationsContext, 0)

        def getRuleIndex(self):
            return EnquestesParser.RULE_alternativa

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAlternativa"):
                return visitor.visitAlternativa(self)
            else:
                return visitor.visitChildren(self)

    def alternativa(self):

        localctx = EnquestesParser.AlternativaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_alternativa)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 81
            self.match(EnquestesParser.AID)
            self.state = 82
            self.match(EnquestesParser.PUNTS)
            self.state = 83
            self.match(EnquestesParser.ALTERNATIVA)
            self.state = 84
            self.implications()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ImplicationsContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IID(self):
            return self.getToken(EnquestesParser.IID, 0)

        def CE(self):
            return self.getToken(EnquestesParser.CE, 0)

        def blocrespostaelement(self):
            return self.getTypedRuleContext(EnquestesParser.BlocrespostaelementContext, 0)

        def CD(self):
            return self.getToken(EnquestesParser.CD, 0)

        def getRuleIndex(self):
            return EnquestesParser.RULE_implications

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitImplications"):
                return visitor.visitImplications(self)
            else:
                return visitor.visitChildren(self)

    def implications(self):

        localctx = EnquestesParser.ImplicationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_implications)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 86
            self.match(EnquestesParser.IID)
            self.state = 87
            self.match(EnquestesParser.CE)
            self.state = 88
            self.blocrespostaelement()
            self.state = 89
            self.match(EnquestesParser.CD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BlocrespostaelementContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def respostaelement(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(EnquestesParser.RespostaelementContext)
            else:
                return self.getTypedRuleContext(EnquestesParser.RespostaelementContext, i)

        def COMA(self, i: int = None):
            if i is None:
                return self.getTokens(EnquestesParser.COMA)
            else:
                return self.getToken(EnquestesParser.COMA, i)

        def getRuleIndex(self):
            return EnquestesParser.RULE_blocrespostaelement

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBlocrespostaelement"):
                return visitor.visitBlocrespostaelement(self)
            else:
                return visitor.visitChildren(self)

    def blocrespostaelement(self):

        localctx = EnquestesParser.BlocrespostaelementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_blocrespostaelement)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 97
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == EnquestesParser.PE:
                self.state = 95
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 6, self._ctx)
                if la_ == 1:
                    self.state = 91
                    self.respostaelement()
                    self.state = 92
                    self.match(EnquestesParser.COMA)
                    pass

                elif la_ == 2:
                    self.state = 94
                    self.respostaelement()
                    pass

                self.state = 99
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RespostaelementContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PE(self):
            return self.getToken(EnquestesParser.PE, 0)

        def NUMERO(self):
            return self.getToken(EnquestesParser.NUMERO, 0)

        def COMA(self):
            return self.getToken(EnquestesParser.COMA, 0)

        def IID(self):
            return self.getToken(EnquestesParser.IID, 0)

        def PR(self):
            return self.getToken(EnquestesParser.PR, 0)

        def getRuleIndex(self):
            return EnquestesParser.RULE_respostaelement

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRespostaelement"):
                return visitor.visitRespostaelement(self)
            else:
                return visitor.visitChildren(self)

    def respostaelement(self):

        localctx = EnquestesParser.RespostaelementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_respostaelement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 100
            self.match(EnquestesParser.PE)
            self.state = 101
            self.match(EnquestesParser.NUMERO)
            self.state = 102
            self.match(EnquestesParser.COMA)
            self.state = 103
            self.match(EnquestesParser.IID)
            self.state = 104
            self.match(EnquestesParser.PR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EnquestaContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EID(self):
            return self.getToken(EnquestesParser.EID, 0)

        def PUNTS(self):
            return self.getToken(EnquestesParser.PUNTS, 0)

        def ENQUESTA(self):
            return self.getToken(EnquestesParser.ENQUESTA, 0)

        def IID(self, i: int = None):
            if i is None:
                return self.getTokens(EnquestesParser.IID)
            else:
                return self.getToken(EnquestesParser.IID, i)

        def getRuleIndex(self):
            return EnquestesParser.RULE_enquesta

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEnquesta"):
                return visitor.visitEnquesta(self)
            else:
                return visitor.visitChildren(self)

    def enquesta(self):

        localctx = EnquestesParser.EnquestaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_enquesta)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 106
            self.match(EnquestesParser.EID)
            self.state = 107
            self.match(EnquestesParser.PUNTS)
            self.state = 108
            self.match(EnquestesParser.ENQUESTA)
            self.state = 112
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 8, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 109
                    self.match(EnquestesParser.IID)
                self.state = 114
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 8, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx
